# JVM (Java Virtual Machine)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F0kg24%2Fbtq4YOOQH4J%2FEF2ISOpkYA36a1flwtLEmK%2Fimg.png)

Java는 JVM이라는 가상머신을 거쳐 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로 바로 컴파일되는 것이 아니라, **JVM이 이해할 수 있는 Java 바이트코드(*.class)로 변환**된다.

Java 컴파일러는 JDK 설치 시 `bin` 디렉터리에 존재하는 `javac.exe`이다.

![](https://i.ibb.co/W62mj8t/image.png)

---

## **Java 코드의 실행 과정**
1. **Java 소스코드 작성**: `.java` 파일 생성.
2. **컴파일 (javac 실행)**: Java 컴파일러(`javac`)를 사용해 소스 코드를 JVM이 이해할 수 있는 **바이트코드 (`.class` 파일)**로 변환.
3. **실행 (JVM 실행)**: JVM이 바이트코드를 읽어 기계어로 변환 후 실행.

---

## **바이트코드와 바이너리 코드**

### **바이트코드(Bytecode)**
- JVM에서 실행되는 **이진 표현법**으로, 명령어의 크기가 **1바이트**.
- 컴퓨터가 직접 실행할 수 있는 기계어가 아니라, JVM에 의해 해석되거나 변환됨.
- **JIT(Just-In-Time) 컴파일러**에 의해 바이너리 코드로 변환됨.

### **바이너리 코드(Binary Code)**
- 컴퓨터가 직접 이해할 수 있는 0과 1로 이루어진 코드.

### **기계어(Machine Code)**
- CPU가 실행할 수 있도록 변환된 코드.
- CPU 제조사마다 기계어가 다르다.

즉, **CPU가 이해하는 코드는 바이너리 코드이며, JVM이 이해하는 코드는 바이트코드이다.**

---

## **JVM 구성 요소**

![](https://velog.velcdn.com/images/jungmyeong96/post/374c653e-bbc9-4499-8bac-54fda17961ff/image.png)

### 1️⃣ **클래스 로더 (Class Loader)**
- `.class` 파일을 JVM에 **로딩(Loading) → 링크(Linking) → 초기화(Initialization)**
- 런타임 시, 필요한 클래스를 **동적으로 메모리에 로드**
- `Class.forName("com.example.MyClass")`을 이용해 동적 로딩 가능

### 2️⃣ **실행 엔진 (Execution Engine)**
- **바이트코드를 기계가 이해할 수 있는 기계어로 변환하여 실행**
- 바이트코드 실행 방식:
    - **인터프리터(Interpreter)**: 한 줄씩 실행 → 속도가 느림
    - **JIT 컴파일러(Just-In-Time Compiler)**: 자주 실행되는 코드를 기계어로 변환하여 캐싱 → 속도가 빠름

### 3️⃣ **가비지 컬렉터 (Garbage Collector, GC)**
- 더 이상 사용되지 않는 객체를 메모리에서 **자동 삭제**하여 메모리 누수를 방지

### 4️⃣ **런타임 데이터 영역 (Runtime Data Area)**
- 프로그램 실행을 위해 OS에서 할당받은 메모리 공간

---

## **JVM 메모리 구조 (T메모리)**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcEjHLD%2Fbtq4YtqCAGY%2FrrVrI45UWSH2LqslkP8Wg0%2Fimg.png)

### 1️⃣ **Method Area (Static 영역)**
- **클래스 정보 및 static 변수, static 메서드 저장**
- 프로그램 시작과 동시에 모든 클래스가 올라가는 것이 아니라, **사용될 때 로드**됨
- **JVM 종료 전까지 유지되며, 모든 쓰레드가 공유**

📌 **주의할 점**
- Static 변수는 **JVM이 종료될 때까지 유지**되므로, **메모리 낭비를 주의해야 한다**
- **읽기 전용이 아닌 Static 변수는 동기화 이슈를 초래할 수 있음**

### 2️⃣ **Stack Area (스택 영역)**
- `{` 중괄호를 만날 때마다 스택 프레임이 생성되고, `}`를 만나면 제거됨
- 기본형 데이터(`int`, `double` 등)는 직접 저장되며, 참조형 데이터는 **Heap 영역을 가리키는 주소값만 저장**

📌 **주의할 점**
- **메서드가 종료되면 해당 스택 프레임은 사라지므로, 지역 변수는 메서드 실행이 끝나면 소멸됨**

### 3️⃣ **Heap Area (힙 영역)**
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmxiE4%2Fbtq4Y5pwyCR%2F3nO3XIf20wUUTrzMKvn5yk%2Fimg.png)
- **객체(인스턴스)가 저장되는 영역**
- 사용이 끝난 객체는 **GC(Garbage Collector)**가 자동으로 삭제

📌 **주의할 점**
- **어떤 참조 변수도 Heap의 객체를 가리키지 않으면, GC에 의해 제거됨**

---

## **JIT 컴파일러 (Just-In-Time Compiler)**
- 프로그램 실행 시 **바이트코드를 기계어로 변환**
- **장점**: 한 번 컴파일된 코드는 캐시에 저장되어 **반복 실행 시 속도가 빠름**
- **최적화 기법**:
    - **인라이닝(Inlining)** → 메서드 호출을 직접 삽입하여 성능 향상
    - **루프 최적화(Loop Optimization)** → 반복문에서 불필요한 연산 제거

---

## **JVM 튜닝 옵션**
- `-Xms<size>` → 초기 힙 크기
- `-Xmx<size>` → 최대 힙 크기
- `-XX:+UseG1GC` → G1 GC 사용
- `-XX:MaxMetaspaceSize=<size>` → 메타스페이스 크기 제한

---

## **정리**
1. **JVM 메모리는 크게 Static, Stack, Heap 영역으로 나뉜다 (T메모리)**
2. **JVM 실행 과정**: `.java` → `.class` (바이트코드) → JVM 실행
3. **JVM 주요 구성 요소**: Class Loader, Execution Engine, GC
4. **JIT 컴파일러와 GC 최적화 기법을 이해하면 성능 개선 가능**
5. **JVM 튜닝 옵션을 활용하면 애플리케이션의 성능을 최적화할 수 있음**

