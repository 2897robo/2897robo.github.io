# **Hash Table (해시 테이블)**

### **개념**
- **Key**와 **Value**의 쌍으로 데이터를 저장하는 자료구조.
- **검색**, **삭제** 시 시간복잡도 **O(1)**을 제공하는 매우 빠른 데이터 접근 방식.

---

### **작동 원리**
1. **해시 함수**를 이용해 **Key**를 **인덱스**로 변환.
    - 예: Key가 '태국'이면, 해시 함수는 이를 숫자로 변환.
    - 이 숫자는 배열의 인덱스로 사용됨.
2. 해당 **인덱스**에 **Value**와 함께 저장됨.
3. 검색 시, 해시 함수가 Key에 대해 다시 같은 숫자를 도출하고 해당 인덱스를 통해 **Value**를 빠르게 찾을 수 있음.

---

### **예시**
- **Key**: '태국' → **Value**: true
- 태국이 해시 테이블에 있는지 검사하려면:
    - '태국'을 해시 함수에 넣고 나온 인덱스로 직접 접근 → **O(1)**의 시간 복잡도.

---

### **해시 충돌 (Hash Collision)**
- 해시 함수가 서로 다른 **Key**에 대해 동일한 **인덱스** 값을 도출하는 상황.
- **충돌 해결 방법**:
    1. **체이닝(Chaining)**: 동일 인덱스에 여러 Key-Value 쌍을 저장. 이때 선형검색을 추가적으로 수행해야 할 수 있음.
        - 예: 동일 인덱스에 2개의 항목을 저장하고, 검색 시 해당 인덱스에서 선형검색 수행.
        - **단점**: O(1)이 아닌, 충돌이 많을 경우 시간 복잡도가 증가할 수 있음.

---

### **장점**
- **빠른 검색/삽입/삭제**: 평균적으로 **O(1)**의 시간 복잡도로 매우 빠름.

---

### **단점**
- **해시 충돌**: 해시 함수가 충돌을 일으킬 수 있어 최악의 경우 O(N) 시간 복잡도가 될 수 있음.
- **메모리 낭비**: 해시 테이블의 크기가 지나치게 크면 메모리 낭비가 발생할 수 있음.
- **동적 크기 조정 필요**: 충돌을 최소화하려면 해시 테이블 크기를 동적으로 조정해야 함.
