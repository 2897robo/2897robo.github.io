# 부동소수점 문제는 왜 발생하는가?

## 개요

프로그래밍 언어에서 부동소수점(Floating-point) 수는 실수를 근사적으로 표현하기 위해 사용됩니다. 그러나 부동소수점 연산 과정에서 발생하는 **정밀도 문제**로 인해 개발자는 종종 예기치 않은 계산 결과를 접하게 됩니다. 이 문서에서는 부동소수점 문제가 왜 발생하는지, 어떤 원리로 인해 부동소수점 표현이 비정확한 결과를 유발하는지 알아보겠습니다.

---

## 부동소수점 표현 방식

대부분의 프로그래밍 언어와 하드웨어는 IEEE 754 표준에 따라 부동소수점을 표현합니다. 이 표준에서는 실수를 **부호 비트(sign bit)**, **지수부(exponent)**, **가수부(mantissa 또는 fraction)**로 나누어 2진수로 표현합니다.

예를 들어, 10진수 실수 0.1을 IEEE 754 방식으로 2진수로 표현하려고 하면, 무한히 반복되는 2진 분수가 필요합니다. 결국 컴퓨터는 이 값을 완벽히 표현할 수 없고, 근사치로 저장하게 됩니다.

---

## 2진 기반의 실수 표현 한계

10진 소수 중 대부분은 2진수로 변환할 때 유한한 길이의 이진 분수로 딱 떨어지지 않습니다. 예를 들어:

- 10진수 0.5는 2진수로 정확히 0.1(2진)입니다.
- 하지만 0.1(10진)은 2진으로 표현하면 0.000110011001100... (2진) 형태로 무한히 반복됩니다.

컴퓨터는 가수부의 길이에 제한이 있기 때문에 무한히 반복되는 이진 분수를 정확히 표현할 수 없습니다. 따라서 내부적으로 가능한 한 근접한 2진 분수를 저장하게 되고, 이로 인해 약간의 오차가 발생합니다.

---

## 정밀도 문제의 실제 예

```java
public class FloatingPointExample {
    public static void main(String[] args) {
        double a = 0.1;
        double b = 0.2;
        double sum = a + b;

        System.out.println("a: " + a); // 0.1 근사값 출력
        System.out.println("b: " + b); // 0.2 근사값 출력
        System.out.println("a + b: " + sum); // 기대: 0.3, 실제: 0.30000000000000004
    }
}
```

위 예제에서 `a + b`는 기대했던 0.3이 아니라 약간 벗어난 0.30000000000000004가 출력됩니다. 이는 0.1과 0.2를 2진수로 근사 표현했기 때문에 발생한 정밀도 손실 때문입니다.

---

## 왜 문제가 되는가?

- **비교 연산 오류**: 실수를 직접 비교할 때 정밀도 문제로 인해 `==` 연산이 실패할 수 있습니다.
- **금융 계산 또는 과학 계산에서의 오차 누적**: 작은 오차가 누적되어 큰 오차로 발전할 수 있습니다.

이러한 이유로 금융 애플리케이션에서는 `BigDecimal` 등 정밀한 수학 연산을 지원하는 타입을 사용하거나, 소수점을 정수로 변환한 후 정수 연산을 수행하는 등의 전략을 활용합니다.

---

## 대처 방법

1. **BigDecimal 사용**: 자바의 `BigDecimal` 클래스 등 정밀도가 중요한 계산에서는 10진 기반의 고정 소수점 연산을 활용.
2. **정수 연산 활용**: 금액을 센트 단위로 환산하는 등, 소수점을 제거하고 정수 연산으로 처리.
3. **오차 허용 범위 고려**: 부동소수점 비교 시 일정 범위의 오차(`epsilon`)를 두어 비교.

---

## 결론

부동소수점 문제는 2진 기반 표현의 한계로 인해 실수를 완벽하게 표현할 수 없기 때문에 발생합니다. 이는 IEEE 754 표준으로 인해 대부분의 컴퓨터 시스템에서 공통적으로 발생하는 문제이며, 근사값 표현으로 인한 정밀도 손실이 연산 결과에 반영되기 때문입니다.

개발자는 이 사실을 이해하고, 정밀도가 필요한 상황에서는 적절한 데이터 타입 또는 처리 전략을 사용하여 부동소수점 문제를 최소화할 수 있습니다.
