# 배열 (Array)

## 메모리
### 비휘발성 메모리 (Non-Volatile Memory)
- **하드 드라이브 (Hard Drive)**: 전원이 꺼져도 데이터를 유지.

### 휘발성 메모리 (Volatile Memory)
- **RAM (Random Access Memory)**:
    - 각 메모리 셀에는 고유한 **주소**가 있으며, 특정 주소로 바로 접근 가능.
    - **랜덤 접근**: 운영체제가 특정 주소(예: 2번 메모리)에 직접 접근하므로 속도가 빠름.
    - 데이터를 순차적으로 탐색할 필요 없이 원하는 위치를 즉시 읽거나 쓸 수 있음.

## 배열의 메모리 관점
- 배열은 **고정된 길이**를 가지며, 메모리 상에서 **연속적으로 저장**됨.
- 프로그램은 배열의 **시작 주소**와 **길이**를 기억하고, 이를 기반으로 요소에 접근.
- 이러한 특성 덕분에 인덱스를 이용한 빠른 데이터 접근이 가능.

---

## 배열 연산
### 1. **Read (읽기)**
- 배열은 0부터 **인덱싱**을 시작.
- 특정 요소에 접근하려면 해당 인덱스 주소로 바로 접근 가능.
- 요소의 **읽기 속도는 배열 길이에 상관없이 일정**하며 매우 빠름.

### 2. **Search (탐색)**
- 특정 값을 찾으려면 배열의 모든 요소를 **순차적으로 확인**해야 함.
- 이는 **선형 검색 (Linear Search)**으로, 배열 길이에 따라 속도가 느려질 수 있음.

### 3. **Insert (삽입)**
- 새로운 데이터를 삽입하려면 기존 데이터를 한 칸씩 **뒤로 밀어내야 함**.
- 삽입 위치에 따라 작업 비용이 커질 수 있음 (특히, 배열 앞부분에 삽입할 경우).

### 4. **Delete (삭제)**
- 데이터를 삭제한 후, 배열의 공백을 **메우기 위해 나머지 요소를 이동**해야 함.
- 삭제 위치에 따라 작업 비용이 달라질 수 있음.

---

### 요약
- 배열은 메모리 상에서 연속적으로 저장되어 **빠른 읽기**가 가능하지만,  
  삽입과 삭제는 데이터를 이동해야 하므로 상대적으로 비용이 높음.
- 탐색 속도는 배열의 크기에 따라 증가하며, **효율적인 검색**을 위해 다른 자료 구조(예: 해시맵)를 사용할 수 있음.