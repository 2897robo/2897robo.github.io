## 1. 시간 복잡도 (Time Complexity)

시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력의 크기 **n**에 대한 함수로 표현합니다. 일반적으로 **빅-오 표기법**을 사용하여 최악의 경우에 소요되는 시간을 나타냅니다.

### 1.1. 빅-오 표기법 (Big-O Notation)

![](https://hangbok-archive.com/wp-content/uploads/2024/03/time-complexity-1.png)

- **O(1)**: **상수 시간**  
  입력 크기와 관계없이 일정한 시간이 소요됩니다.  
  예시: 배열의 첫 번째 원소를 출력하는 작업.

- **O(log n)**: **로그 시간**  
  입력 크기 **n**이 커질수록 시간이 천천히 증가합니다. 주로 **이진 탐색**에서 나타납니다.  
  예시: 이진 탐색(Binary Search).

- **O(n)**: **선형 시간**  
  입력 크기 **n**에 비례하여 시간이 증가합니다.  
  예시: 배열의 모든 원소를 출력하는 작업.

- **O(n log n)**: **선형 로그 시간**  
  이 시간 복잡도는 보통 **효율적인 정렬 알고리즘**(예: 퀵소트, 병합 정렬)에서 나타납니다.  
  예시: 퀵소트(QuickSort), 병합 정렬(MergeSort).

- **O(n²)**: **이차 시간**  
  입력 크기 **n**이 커질수록 시간이 빠르게 증가합니다. 주로 **버블 정렬**이나 **선택 정렬**에서 나타납니다.  
  예시: 버블 정렬(Bubble Sort), 선택 정렬(Selection Sort).

- **O(2^n)**: **지수 시간**  
  매우 빠르게 시간이 증가합니다. 주로 **완전 탐색** 알고리즘에서 나타납니다.  
  예시: 피보나치 수열 계산(단순 재귀 방식), 여행하는 외판원 문제(Travelling Salesman Problem).

- **O(n!)**: **팩토리얼 시간**  
  매우 비효율적이며, 입력 크기가 커질수록 실행 시간이 매우 길어집니다.  
  예시: 순열을 생성하는 알고리즘.

### 1.2. 시간 복잡도 예시

1. **O(1)**:
```java
public int constantTimeExample(int[] arr) {
    return arr[0]; // 배열의 첫 번째 원소 반환
}
```
배열의 첫 번째 원소를 반환하는 함수는 입력 크기와 관계없이 **O(1)**의 시간 복잡도를 가집니다.

2. **O(n)**:
```java
public void linearTimeExample(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        System.out.println(arr[i]); // 배열의 모든 원소 출력
    }
}
```
배열의 모든 원소를 출력하는 함수는 배열 크기 **n**에 비례하여 시간이 걸리므로 **O(n)**입니다.

3. **O(n²)**:
```java
public void quadraticTimeExample(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length; j++) {
            System.out.println(arr[i] + " " + arr[j]); // 중첩 반복문
        }
    }
}
```
두 개의 중첩된 반복문을 사용한 예시로, 배열 크기 **n**에 대해 **O(n²)**의 시간 복잡도를 가집니다.

---

## 2. 공간 복잡도 (Space Complexity)

공간 복잡도는 알고리즘이 실행되는 동안 필요한 메모리의 양을 나타냅니다. 시간 복잡도와 마찬가지로 **n**에 대한 함수로 표현되며, 알고리즘이 사용하는 메모리 공간이 입력 크기에 따라 어떻게 변하는지 평가합니다.

### 2.1. 빅-오 표기법을 이용한 공간 복잡도

- **O(1)**: **상수 공간**  
  알고리즘이 사용하는 메모리 공간이 입력 크기와 관계없이 일정한 경우.  
  예시: 단일 변수만 사용하는 알고리즘.

- **O(n)**: **선형 공간**  
  알고리즘이 입력 크기 **n**에 비례하여 메모리 공간을 사용하는 경우.  
  예시: 입력 배열을 저장하는 알고리즘.

- **O(n²)**: **이차 공간**  
  메모리 사용량이 입력 크기 **n**의 제곱에 비례하는 경우.  
  예시: 2D 배열을 사용하는 알고리즘.

### 2.2. 공간 복잡도 예시

1. **O(1)**:
```java
public int constantSpaceExample(int[] arr) {
    int total = 0; // 단일 변수만 사용
    for (int num : arr) {
        total += num; 
    }
    return total;
}
```
이 예시는 배열의 크기와 관계없이 **O(1)**의 공간 복잡도를 가집니다. 변수 **total**만 사용하기 때문입니다.

2. **O(n)**:
```java
public int[] linearSpaceExample(int[] arr) {
    int[] result = new int[arr.length]; // 입력 크기와 동일한 배열 생성
    for (int i = 0; i < arr.length; i++) {
        result[i] = arr[i] * 2; 
    }
    return result;
}
```
이 예시는 입력 배열의 크기 **n**에 비례하여 새로운 배열을 생성하므로 **O(n)**의 공간 복잡도를 가집니다.

---

## 3. 알고리즘 복잡도의 중요성

### 3.1. 성능 최적화
알고리즘 복잡도 분석을 통해 성능을 최적화할 수 있습니다. 예를 들어, **O(n²)**의 시간 복잡도를 가진 알고리즘은 **O(n log n)** 알고리즘으로 개선할 수 있다면, 입력 크기가 커졌을 때 훨씬 더 효율적으로 동작할 수 있습니다.

### 3.2. 리소스 제한
실제 환경에서는 **시간**과 **메모리**가 제한적이기 때문에, 알고리즘을 설계할 때 복잡도를 고려하여 자원을 효율적으로 사용할 수 있어야 합니다.

### 3.3. 알고리즘 선택
어떤 알고리즘을 사용할지는 문제의 크기와 성격에 따라 달라집니다. 예를 들어, 작은 입력에는 **O(n²)** 알고리즘이 괜찮을 수 있지만, 입력 크기가 커지면 **O(n log n)** 알고리즘이 더 효율적입니다.

---

## 4. 정리

| 연산 종류    | 기호     | 설명                                       |
| ------------ | -------- | ------------------------------------------ |
| 시간 복잡도 | O(1)     | **상수 시간** – 입력 크기와 관계없이 일정한 시간 |
| 시간 복잡도 | O(log n) | **로그 시간** – 입력 크기가 커질수록 천천히 증가 |
| 시간 복잡도 | O(n)     | **선형 시간** – 입력 크기에 비례하여 시간 증가 |
| 시간 복잡도 | O(n log n) | **선형 로그 시간** – 효율적인 정렬 알고리즘에서 사용 |
| 시간 복잡도 | O(n²)    | **이차 시간** – 중첩된 반복문에서 발생 |
| 공간 복잡도 | O(1)     | **상수 공간** – 입력 크기와 관계없이 일정한 메모리 |
| 공간 복잡도 | O(n)     | **선형 공간** – 입력 크기에 비례하여 메모리 증가 |

알고리즘 복잡도 분석은 알고리즘의 효율성을 평가하고, 이를 통해 성능을 최적화하거나 적합한 알고리즘을 선택하는 데 중요한 역할을 합니다.