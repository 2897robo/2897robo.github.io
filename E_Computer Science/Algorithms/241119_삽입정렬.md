# **삽입 정렬 (Insertion Sort)**

![](https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif)

### **개념**
- 정렬되지 않은 배열에서 **현재 값을 정렬된 영역에 삽입**.
- 작은 데이터를 정렬할 때 유용하며, 이미 정렬된 배열에 가까운 경우 효율적임.

---

### **작동 방식**
1. **첫 번째 인덱스(0번)**는 이미 정렬된 상태로 간주.
2. **두 번째 인덱스(1번)**부터 시작:
    - 현재 값을 왼쪽 요소와 비교.
    - 왼쪽 값이 더 크면 값을 교환(Swap)하고, 왼쪽으로 이동해 계속 비교.
    - 적절한 위치에 도달하면 삽입 완료.
3. 다음 인덱스로 이동해 동일 작업 반복.
4. 배열의 끝까지 반복.

---

### **시간복잡도**
- 최선의 경우(이미 정렬된 경우): **O(N)** (비교만 수행).
- 최악의 경우(역순 정렬된 경우): **O(N^2)** (모든 요소를 비교하고 이동).

---

### **예시**

#### 배열: [4, 3, 2, 1] (정렬 과정)
1. **1번째 싸이클**
    - 인덱스 1의 값(3)을 인덱스 0의 값(4)과 비교 → **스왑** → [3, 4, 2, 1]
2. **2번째 싸이클**
    - 인덱스 2의 값(2)을 인덱스 1의 값(4)과 비교 → **스왑** → [3, 2, 4, 1]
    - 인덱스 1의 값(3)과 비교 → **스왑** → [2, 3, 4, 1]
3. **3번째 싸이클**
    - 인덱스 3의 값(1)을 인덱스 2의 값(4)와 비교 → **스왑** → [2, 3, 1, 4]
    - 인덱스 2의 값(3)과 비교 → **스왑** → [2, 1, 3, 4]
    - 인덱스 1의 값(2)와 비교 → **스왑** → [1, 2, 3, 4]
4. **완료**: [1, 2, 3, 4]

---

### **특징**
- **장점**:
    - 데이터가 이미 정렬된 상태에 가까울수록 효율적.
    - **안정 정렬**: 같은 값의 순서가 유지됨.
- **단점**:
    - 최악의 경우 시간복잡도 **O(N^2)**.
    - 큰 데이터셋에 비효율적.

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;

        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;

            // 현재 key보다 큰 요소를 한 칸씩 뒤로 이동
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            // key를 적절한 위치에 삽입
            arr[j + 1] = key;
        }
    }
}
```