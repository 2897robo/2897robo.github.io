# **📌 트랜잭션(Transaction), ACID 원칙, 정합성(Consistency) & 무결성(Integrity) 개념 정리**

## **🚀 1. 트랜잭션(Transaction)**
**✅ 트랜잭션이란?**  
👉 **"하나의 논리적 작업 단위"**  
👉 **여러 개의 SQL 연산을 하나의 묶음으로 처리함.**  
👉 **트랜잭션이 성공하면 `COMMIT`, 실패하면 `ROLLBACK`**

**💡 예시: 은행 계좌 이체**
- 김기욱(계좌 A) → **50만 원** 송금 → 이순신(계좌 B)
- 이 과정에서 SQL 연산이 실행됨:
    1. **김기욱 계좌(A)에서 50만 원 차감**
       ```sql
       UPDATE account SET balance = balance - 500000 WHERE user_id = '김기욱';
       ```
    2. **이순신 계좌(B)에 50만 원 추가**
       ```sql
       UPDATE account SET balance = balance + 500000 WHERE user_id = '이순신';
       ```
    3. **트랜잭션 완료 후 COMMIT**
       ```sql
       COMMIT;
       ```

💡 **그런데 만약, 2번까지 수행한 상태에서 DB 서버가 다운되면?**
- 김기욱 계좌(A)에서는 50만 원이 빠졌지만,  
  이순신 계좌(B)에서는 입금되지 않음!  
  **→ 데이터 불일치 발생!** 🚨
- **그래서 트랜잭션을 사용하여 "모든 연산이 성공하면 COMMIT, 실패하면 ROLLBACK"을 보장함.**

✔ **트랜잭션 적용 후**
- **실패 시 ROLLBACK** 실행:
  ```sql
  ROLLBACK;
  ```
  → 김기욱의 계좌에서 빠진 50만 원을 원래대로 복구!

---

## **🚀 2. ACID 원칙**
트랜잭션은 **ACID 원칙**을 따라야 해.  
**ACID 원칙이 깨지면 데이터가 망가질 수 있음.**

| 개념 | 설명 | 예시 |
|------|------|------|
| **A (Atomicity, 원자성)** | 트랜잭션은 "모두 수행되거나, 모두 롤백"되어야 함 | **송금 중 오류 발생 시 ROLLBACK (한쪽 계좌에서만 돈이 빠지는 걸 방지!)** |
| **C (Consistency, 일관성)** | 트랜잭션 실행 후에도 **DB가 일관된 상태** 유지 | **계좌 이체 후, 총 은행 잔고의 합은 변하지 않아야 함** |
| **I (Isolation, 고립성)** | 동시에 실행되는 트랜잭션이 서로 영향을 주면 안 됨 | **A→B로 송금 중일 때, B가 잔고를 조회해도 입금이 반영되면 안 됨** |
| **D (Durability, 지속성)** | 트랜잭션이 `COMMIT`된 후에는 **데이터가 영구적으로 저장**되어야 함 | **송금 후 전원이 나가도, 데이터가 보존되어야 함** |

---

## **🚀 3. 정합성(Consistency) & 무결성(Integrity)**
👉 **정합성과 무결성은 데이터가 "올바른 상태"를 유지하는 것과 관련 있음**

### **✅ 3-1. 정합성(Consistency)**
👉 **데이터의 일관성을 유지하는 것 (데이터가 모순되지 않게 보장)**  
👉 트랜잭션이 끝난 후에도 **DB의 상태가 항상 올바르게 유지되어야 함**

💡 **예시: 은행 시스템**
1. 계좌 이체 전, **은행 총 잔고 = 10억 원**
2. A가 B에게 100만 원 송금  
   → A 잔고 -100만, B 잔고 +100만
3. 트랜잭션 완료 후, **은행 총 잔고 = 10억 원 (변동 없음)**

✔ **정합성이 깨지는 경우:**
- A 계좌에서 -100만 원 빠졌는데,  
  B 계좌에서 +100만 원이 안 들어옴 🚨  
  → **이러면 데이터가 모순됨!**

✔ **해결 방법:**
- **트랜잭션 적용 (`ROLLBACK` 사용)**
- **무결성 제약 조건(FK, CHECK 등) 활용하여 강제**

---

### **✅ 3-2. 무결성(Integrity)**
👉 **데이터의 정확성과 신뢰성을 보장하는 제약 조건**  
👉 **DB의 데이터가 "엉터리 값"으로 들어가지 못하도록 방지**

✔ **무결성의 종류**
1. **개체 무결성 (Entity Integrity)**
    - **기본키(PK)는 중복되거나 NULL이 될 수 없음**
    - ❌ `INSERT INTO users (id, name) VALUES (NULL, '김기욱');`
    - **🔥 "PK는 반드시 값이 있어야 한다!"**

2. **참조 무결성 (Referential Integrity)**
    - **외래키(FK)가 참조하는 데이터가 존재해야 함**
    - ❌ `INSERT INTO orders (order_id, user_id) VALUES (1, 9999);`  
      → `user_id=9999`는 users 테이블에 없으므로 **오류 발생**
    - **🔥 "없는 사용자의 주문을 기록할 수 없다!"**

3. **도메인 무결성 (Domain Integrity)**
    - **컬럼 값은 정해진 데이터 타입을 만족해야 함**
    - ❌ `INSERT INTO users (age) VALUES ('스물다섯');`  
      → `age` 컬럼이 INT 타입이므로 **문자 입력 불가능**
    - **🔥 "데이터 타입을 지켜야 한다!"**

4. **고유성 무결성 (Unique Integrity)**
    - **특정 컬럼의 값이 중복되지 않아야 함**
    - ❌ `INSERT INTO users (email) VALUES ('test@email.com');`  
      → 같은 이메일이 이미 존재하면 오류 발생 (UNIQUE 제약조건 때문)
    - **🔥 "중복되면 안 되는 값은 UNIQUE로 설정!"**

---

## **📌 요약 정리**
| 개념 | 설명 | 예시 |
|------|------|------|
| **트랜잭션(Transaction)** | 하나의 논리적 작업 단위 | **은행 송금: A → B 계좌 이체 (성공하면 COMMIT, 실패하면 ROLLBACK)** |
| **ACID 원칙** | 트랜잭션의 4가지 핵심 원칙 | **A(원자성) / C(일관성) / I(고립성) / D(지속성)** |
| **정합성(Consistency)** | 데이터의 "일관성"을 유지하는 것 | **은행 총 잔고는 변하지 않아야 함** |
| **무결성(Integrity)** | 데이터의 정확성을 보장하는 제약 조건 | **PK는 NULL 불가, FK는 참조 데이터 필요, 데이터 타입 유지, 중복 금지** |
